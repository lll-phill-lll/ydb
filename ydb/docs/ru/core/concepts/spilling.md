# Спиллинг

## Понятие спиллинга

**Спиллинг** (от англ. *spilling*) — это механизм управления памятью, при котором данные, превышающие доступный объём оперативной памяти, временно выгружаются на диск. Это позволяет продолжать выполнение операций без аварийного завершения и эффективно использовать ресурсы в условиях ограниченной RAM.

В системах обработки данных, включая YDB, спиллинг важен для:

- обработки объёмов данных, превышающих объём оперативной памяти;
- предотвращения ошибок "Out of Memory" (OOM);
- устойчивой работы при пиковых нагрузках и непредсказуемых сценариях использования памяти.

## Принципы работы спиллинга

### Основные концепции

Спиллинг функционирует на основе принципа иерархии памяти:

1. **Оперативная память (RAM)** — быстрый, но ограниченный ресурс.
2. **Дисковое хранилище** — медленное, но ёмкое.

Когда использование памяти приближается к лимиту, система:

- сериализует часть данных;
- сохраняет их во временные файлы на диске;
- освобождает соответствующую память;
- при необходимости — загружает данные обратно в память для продолжения вычислений.


## Спиллинг в YDB

### Архитектура спиллинга в YDB
Механизм спиллинга в YDB включает два основных уровня: бэкенд - сервис для хранения данных на диске, и фронтенд - компоненты, которые взаимодействуют с этим сервисом и управляют памятью.

#### Сервис спиллинга (Spilling Service)

Данный компонент представляет собой [акторный сервис](glossary.md#actor-service), который инициализируется при старте узла. Сервис обозначается как **Spilling Service**.

Сервис обрабатывает задачи (или события в терминах [акторной системы](glossary.md#actor-system)). События могут содержать следующие типы заданий:

* сохранение блоба данных.
* загрузка блоба данных.
* удаление блоба данных.

Главная функция сервиса заключается в реализации хранилища, которое сохраняет блоб данных по предоставленному клиентом идентификатору и обеспечивает получение блоба по этому идентификатору.

Основные компоненты сервиса:

**Очередь задач**: Сервис поддерживает внутреннюю очередь операций записи и чтения. Все запросы на спиллинг помещаются в данную очередь и обрабатываются асинхронно.

**Пул потоков**: Для выполнения операций ввода-вывода используется пул рабочих потоков. Количество потоков [конфигурируется](../../devops/configuration-management/configuration-v2/spilling-config.md#workerscount) и влияет на производительность сервиса.

**Управление файлами**: Сервис автоматически создает, удаляет и управляет файлами на диске. 

**Мониторинг ресурсов**: Сервис осуществляет мониторинг использования дискового пространства, количества активных операций и других метрик производительности.

#### Хранение данных

Данные сохраняются в файлах на локальной файловой системе. Spilling Service обеспечивает:

* распределение записей между файлами;
* удаление файлов;
* управление жизненным циклом данных.

При непредвиденном перезапуске устаревшие файлы удаляются автоматически.

#### Компоненты, использующие спиллинг

Компоненты системы интегрированы с Spilling Service и взаимодействуют с ним через события акторной системы:

**Мониторинг состояния памяти**: Вычислительные узлы осуществляют постоянный мониторинг состояния памяти через аллокатор. Аллокатор информирует узлы о снижении объема свободной памяти. Однако, система не дожидается полного исчерпания памяти, поскольку процесс спиллинга также требует дополнительных ресурсов памяти для сериализации и буферизации данных.

**Отправка событий**: При обнаружении необходимости спиллинга данных вычислительный компонент (канал передачи данных или вычислительное ядро) выполняет следующие действия:

1. Сериализует данные в блоб
2. Генерирует уникальный идентификатор для блоба
3. Создает событие спиллинга (`TEvWrite`) с блобом и сгенерированным идентификатором
4. Отправляет событие в Spilling Service
5. **Приостанавливает выполнение** и переходит в состояние ожидания

**Ожидание результатов**: После отправки события вычислительный компонент педедает выполнение другим компонентам и сам перестает выполняться, до тех пор, пока блоб не будет физически записан на диск.

**Обработка ответов**: Spilling Service обрабатывает событие и возвращает новое событие `TEvWriteResult` с подтверждением записи по указанному идентификатору или `TEvError` в случае ошибки. Продолжение работы вычислительного компонента возможно только после получения подтверждения.

**Схема взаимодействия при спиллинге:**

**Процесс записи данных (спиллинг):**

```mermaid
sequenceDiagram
    participant AL as Аллокатор памяти
    participant CN as Вычислительный узел
    participant SS as Spilling Service
    participant FS as Файловая система

    Note over AL: Мониторинг состояния памяти
    AL->>CN: Сигнал: память заканчивается (Yellow Zone)
    CN->>CN: Принятие решения о спиллинге
    CN->>CN: Сериализация данных в блоб
    CN->>SS: TEvWrite (блоб + уникальный ID)
    Note over CN: Прекращение выполнения<br/>и ожидание подтверждения
    SS->>SS: Постановка в очередь задач
    SS->>FS: Асинхронная запись данных на диск
    FS->>SS: Подтверждение успешной записи
    SS->>CN: TEvWriteResult (успех + ID)
    Note over CN: Продолжение выполнения
```

**Процесс чтения данных (восстановление):**

```mermaid
sequenceDiagram
    participant CN as Вычислительный узел
    participant SS as Spilling Service
    participant FS as Файловая система

    Note over CN: Необходимость восстановления<br/>спилленных данных
    CN->>SS: TEvRead (ID блоба)
    Note over CN: Ожидание восстановления данных
    SS->>FS: Чтение данных с диска по ID
    FS->>SS: Данные блоба
    SS->>SS: Десериализация данных
    SS->>CN: TEvReadResult (восстановленные данные)
    Note over CN: Продолжение обработки<br/>с восстановленными данными
```

**Чтение данных**: При необходимости восстановления данных компонент отправляет событие `TEvRead` с идентификатором блоба. Spilling Service читает данные с диска и возвращает событие `TEvReadResult` с восстановленными данными. Во время ожидания данных вычисления также приостанавливаются.

### Типы спиллинга в YDB

В YDB реализованы два основных типа спиллинга, функционирующие на различных уровнях вычислительного процесса:

#### 1. Спиллинг внутри вычислительных ядер (Compute Node Spilling)

Вычислительные ядра YDB автоматически выгружают промежуточные данные на диск при выполнении операций, требующих значительного объема памяти. Данный тип спиллинга реализован на уровне отдельных вычислительных операций и активируется при достижении лимитов памяти.

**Основные сценарии использования:**

* **Агрегации** — при группировке больших объемов данных система выгружает промежуточные хеш-таблицы на диск
* **Сортировки** — при сортировке результатов, превышающих доступную память, применяется внешняя сортировка с использованием временных файлов
* **Join операции** — при объединении таблиц большого размера используется алгоритм Grace Hash Join с разделением данных на партиции и их выгрузкой на диск

**Механизм функционирования:**

Вычислительные узлы содержат специализированные объекты для мониторинга использования памяти. При приближении объема данных к установленному лимиту:

1. Система переключается в режим спиллинга
2. Данные сериализуются и разделяются на блоки (бакеты)
3. Часть блоков передается в Spilling Service для сохранения на диск
4. В памяти сохраняется метаинформация о расположении данных
5. При необходимости данные загружаются обратно и обрабатываются

```sql
-- Пример запроса, который может инициировать спиллинг в вычислительных ядрах
SELECT 
    user_id,
    COUNT(*) as orders_count,
    SUM(amount) as total_amount
FROM orders 
GROUP BY user_id 
ORDER BY total_amount DESC;
```

#### 2. Спиллинг в каналах между задачами (Channel Spilling)

Данный тип спиллинга функционирует на уровне передачи данных между различными этапами выполнения запроса. Каналы передачи данных автоматически буферизуют и выгружают данные при переполнении буферов. Это помогает не блокировать выполнение узла, генерирующего данные, даже в ситуациях, когда принимающий узел не готов принять данные.

**Механизм функционирования:**

Каналы передачи данных осуществляют постоянный мониторинг своего состояния:

1. **Буферизация**: Входящие данные накапливаются во внутренних буферах канала
2. **Контроль заполнения**: Система отслеживает уровень заполнения буферов (NoLimit, SoftLimit, HardLimit)
3. **Автоматический спиллинг**: При достижении лимитов данные автоматически сериализуются и передаются в Spilling Service
4. **Продолжение функционирования**: Канал продолжает прием новых данных после освобождения места в памяти
5. **Восстановление**: При готовности следующего этапа данные читаются с диска и передаются далее

#### Интеграция типов спиллинга

Оба типа спиллинга функционируют совместно и могут активироваться одновременно в рамках одного запроса. Например, при выполнении сложного аналитического запроса:

## См. также

- [Конфигурация спиллинга](../../devops/configuration-management/configuration-v2/spilling-config.md)
- [Мониторинг YDB](../../devops/observability/monitoring.md)
- [Диагностика производительности](../../troubleshooting/performance/index.md)
