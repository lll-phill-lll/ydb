# Спиллинг

## Спиллинг в общем

**Спиллинг** — это механизм управления памятью, при котором промежуточные данные, возникающие в результате вычислений и превышающие доступный объём оперативной памяти узла, временно выгружаются во внешнее хранилище. В {{ ydb-short-name }} для спиллинга в настоящее время используется диск. Спиллинг обеспечивает выполнение пользовательских запросов, которые требуют обработки больших объёмов данных, превышающих доступную память узла.

В системах обработки данных, включая {{ ydb-short-name }}, спиллинг важен для:

- обработки запросов с большими объёмами данных, когда промежуточные результаты не помещаются в оперативную память;
- выполнения сложных аналитических операций (агрегации, соединения таблиц) над большими наборами данных;
- оптимизации производительности запросов за счет промежуточной материализации части данных во внешней памяти, что в определенных сценариях может ускорить общее время выполнения.

Спиллинг функционирует на основе принципа иерархии памяти:

1. **Оперативная память (RAM)** — быстрый, но ограниченный ресурс.
2. **Внешняя память** — медленнее, но более ёмкая.

Когда использование памяти приближается к лимиту, система:

- сериализует часть данных;
- сохраняет их во внешней памяти;
- освобождает соответствующую память;
- продолжает обработку запроса, используя данные, находящиеся в памяти;
- при необходимости загружает данные обратно в память для продолжения вычислений.


## Спиллинг в {{ ydb-short-name }} {#architecture}

{{ ydb-short-name }} реализует механизм спиллинга через **Spilling Service** — [акторный сервис](glossary.md#actor-service), который предоставляет временное хранилище для блобов данных. Спиллинг осуществляется только на [узлах базы данных](glossary.md#database-node). Подробная техническая информация о Spilling Service доступна в разделе [Spilling Service](../contributor/spilling-service.md).

### Типы спиллинга в {{ ydb-short-name }}

{{ ydb-short-name }} реализует два основных типа спиллинга, функционирующие на различных уровнях вычислительного процесса. Эти типы работают независимо друг от друга и могут активироваться одновременно в рамках одного запроса, обеспечивая комплексное управление памятью.

#### Спиллинг вычислительных ядер

Вычислительные ядра {{ ydb-short-name }} автоматически выгружают промежуточные данные на диск при выполнении операций, требующих значительного объема памяти. Данный тип спиллинга реализован на уровне отдельных вычислительных операций и активируется при достижении лимитов памяти.

**Основные сценарии использования:**

* **Агрегации** — при группировке больших объемов данных система выгружает промежуточные хеш-таблицы на диск

* **Join операции** — при объединении таблиц большого размера используется алгоритм Grace Hash Join с разделением данных на партиции и их выгрузкой на диск

##### Механизм функционирования

Вычислительные узлы содержат специализированные объекты для мониторинга использования памяти. При приближении объема данных к установленному лимиту:

1. Система переключается в режим спиллинга
2. Данные сериализуются и разделяются на блоки (бакеты)
3. Часть блоков передается в Spilling Service для сохранения на диске
4. В памяти сохраняется метаинформация о расположении данных
5. Система продолжает обработку данных, оставшихся в памяти, что позволяет освободить дополнительное место
6. При необходимости данные загружаются обратно и обрабатываются

```sql
-- Пример запроса, который может инициировать спиллинг в вычислительных ядрах
SELECT
    user_id,
    COUNT(*) as orders_count,
    SUM(amount) as total_amount
FROM orders
GROUP BY user_id
ORDER BY total_amount DESC;
```

#### Спиллинг каналов

Данный тип спиллинга функционирует на уровне передачи данных между различными этапами выполнения запроса. Каналы передачи данных автоматически буферизуют и выгружают данные при переполнении буферов. Это помогает не блокировать выполнение узла, генерирующего данные, даже в ситуациях, когда один из принимающих узлов не готов принять данные.

##### Механизм функционирования

Каналы передачи данных осуществляют постоянный мониторинг своего состояния:

1. **Буферизация**: Входящие данные накапливаются во внутренних буферах канала
2. **Контроль заполнения**: Система отслеживает уровень заполнения буферов
3. **Автоматический спиллинг**: При достижении лимитов данные автоматически сериализуются и передаются в Spilling Service
4. **Продолжение функционирования**: Канал продолжает прием новых данных после освобождения места в памяти
5. **Восстановление**: При готовности следующего этапа данные читаются из внешнего хранилища и передаются далее

## Взаимодействие с контроллером памяти

При выполнении запросов {{ ydb-short-name }} старается умещаться в заданный лимит памяти, который устанавливается [контроллером памяти](../reference/configuration/memory_controller_config.md). Чтобы продолжать помещаться в этот лимит даже при росте промежуточных вычислений, используется спиллинг. Подробнее см. раздел [Управление памятью](../reference/configuration/table_service_config.md#memory-management).

## См. также

- [Spilling Service](../contributor/spilling-service.md)
- [Конфигурация спиллинга](../reference/configuration/table_service_config.md)
- [Мониторинг {{ ydb-short-name }}](../devops/observability/monitoring.md)
- [Диагностика производительности](../troubleshooting/performance/index.md)
